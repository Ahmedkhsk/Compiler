    //tokenTypes[2] = "Open";
    //tokenTypes[3] = "Number";
    //tokenTypes[4] = "Color";
    //tokenTypes[5] = "Comma";
    //tokenTypes[6] = "Close";

    //set<string> validColors = { "red", "blue", "green", "yellow" };

    //cout << "Enter your string: ";
    //string line;
    //getline(cin, line);

    //stringstream ss(line);
    //string token;

    //while (ss >> token) {
    //    int currentState = startState;
    //    string lexeme = "";
    //    bool isValid = true;

    //    for (char ch : token) {
    //        if (transitionFunction.find({ currentState, ch }) != transitionFunction.end()) {
    //            currentState = transitionFunction[{currentState, ch}];
    //            lexeme += ch;
    //        }
    //        else {
    //            isValid = false;
    //            break;
    //        }
    //    }

    //    if (isValid && finalStates.at(currentState) != finalStates.end()) {
    //        if (tokenTypes[currentState] == "Color" && validColors.find(lexeme) == validColors.end()) {
    //            cout << lexeme << " => Invalid Token" << endl;
    //        }
    //        else {
    //            cout << lexeme << " => " << tokenTypes[currentState] << endl;
    //        }
    //    }
    //    else {
    //        cout << lexeme << " => Invalid Token" << endl;
    //    }
    //}


______________________________

#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
using namespace std;

int main()
{
	ifstream inputAplphabet("Alphabet.txt");
	vector<char> alphabets;
	char c;
	while (inputAplphabet>>c)
	{
		alphabets.push_back(c);
	}

	ifstream inputAutomaton("Automaton.txt");
	int numberOfStates, startState, numberOfFinalStates;
	vector<int> finalStates;

	inputAutomaton >> numberOfStates >> startState >> numberOfFinalStates;
	for (int i = 0; i < numberOfFinalStates; i++)
	{
		int finals;
		inputAutomaton >> finals;
		finalStates.push_back(finals);
	}

	ifstream inputTransition("Transition.txt");
	map<pair<int, char>, int> transitionFaunction;
	int fromState, toState;
	while (inputTransition >> fromState >> c >> toState)
	{
		transitionFaunction[{fromState, c}] = toState;
	}

	return 0;
}

Ø§Ù†Ø§ Ø¹Ø§ÙˆØ² Ø¨Ø§Ù„ÙŠ Ù…ÙˆØ¶Ø­ ÙÙŠ Ø§Ù„ØµÙˆØ±Ù‡ Ùˆ Ø§Ù„ÙƒÙˆØ¯ 
Ø§Ù†Ø§ Ø¯Ù„ÙˆÙ‚ØªÙŠ Ø¨Ø¹Ù…Ù„ Ø§Ø³ÙƒØ§Ù†Ø± 
ÙØ¹Ø§ÙˆØ² ÙØ§ÙŠÙ†Ù„ Ø§Ù„ØªÙˆÙƒÙŠÙ†Ø² 
ÙŠØ¨Ù‚ÙŠ 
ÙÙŠÙ‡ Ù…Ø«Ù„Ø§ 
(1,red) => Ø¯Ù‡ ÙŠØ§Ø®Ø¯Ù‡ Ù…Ù† Ø§Ù„ÙŠÙˆØ²Ø±
ÙŠÙ‚ÙˆÙ„ÙŠ 
( => Open 
1 => Number
, => Comma
red => Color
) => Close

Ø·ÙŠØ¨ Ù„Ùˆ Ø§Ø¯ÙŠØªÙ‡ 
(blue
( => Open
blue => Color
ÙŠØ¨Ù‚ÙŠ Ø§Ù„ØªÙˆÙƒÙŠÙ† Ø§Ù„ÙŠ ÙØ§Øª Ø¯Ù‡ ÙØ§Ù„ÙŠØ¯ Ø¹Ø§Ø¯ÙŠ 
Ø¨Øµ Ø¯Ù‡ Ø¨Ù‚ÙŠ 
,flr
Ù‡Ùˆ Ù‡ÙŠØ¹Ù…Ù„ Ø§ÙŠÙ‡ 
, => Comma
flr => inValid token
Ù„ÙŠÙ‡ Ø¨Ù‚ÙŠ Ø¹Ø´Ø§Ù† Ø¯ÙŠ Ù…Ø´ Color Ù…ØªØ¹Ø§Ø±Ù Ø¹Ù„ÙŠÙ‡ Ø§ØµÙ„Ø§ ÙˆÙ„Ø§ Ø¨ØªØ³Ø§ÙˆÙŠ Ø­Ø§Ø¬Ù‡ ØªØ§Ù†ÙŠÙ‡




______________________




#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <sstream>
using namespace std;

int main() {
    // ğŸ”¹ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø£Ø¨Ø¬Ø¯ÙŠØ©
    ifstream inputAlphabet("Alphabet.txt");
    set<char> alphabets;
    char c;
    while (inputAlphabet >> c) {
        alphabets.insert(c);
    }

    // ğŸ”¹ Ù‚Ø±Ø§Ø¡Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª DFA
    ifstream inputAutomaton("Automaton.txt");
    int numberOfStates, startState, numberOfFinalStates;
    set<int> finalStates;

    inputAutomaton >> numberOfStates >> startState >> numberOfFinalStates;
    for (int i = 0; i < numberOfFinalStates; i++) {
        int finalState;
        inputAutomaton >> finalState;
        finalStates.insert(finalState);
    }

    // ğŸ”¹ Ù‚Ø±Ø§Ø¡Ø© Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„Ø§Øª (Transitions)
    ifstream inputTransition("Transition.txt");
    map<pair<int, char>, int> transitionFunction;
    int fromState, toState;
    while (inputTransition >> fromState >> c >> toState) {
        transitionFunction[{fromState, c}] = toState;
    }

    // ğŸ”¹ ØªØ¹Ø±ÙŠÙ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù„ÙƒÙ„ Ø­Ø§Ù„Ø© Ù†Ù‡Ø§Ø¦ÙŠØ©
    map<int, string> tokenTypes;
    tokenTypes[2] = "Open";
    tokenTypes[3] = "Number";
    tokenTypes[4] = "Color";
    tokenTypes[5] = "Comma";
    tokenTypes[6] = "Close";

    // ğŸ”¹ ØªØ¹Ø±ÙŠÙ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©
    set<string> validColors = {"red", "blue", "green", "yellow"}; // Ø£Ø¶Ù Ø£ÙŠ Ø£Ù„ÙˆØ§Ù† Ø£Ø®Ø±Ù‰

    // ğŸ”¹ Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    cout << "Enter your string: ";
    string line;
    getline(cin, line); // Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø³Ø·Ø± Ø¨Ø§Ù„ÙƒØ§Ù…Ù„

    stringstream ss(line);
    string token;
    
    // ğŸ”¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
    while (ss >> token) {
        int currentState = startState;
        string lexeme = "";
        bool isValid = true;

        // ğŸ”¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªÙˆÙƒÙ† Ø­Ø±ÙÙ‹Ø§ Ø¨Ø­Ø±Ù Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… DFA
        for (char ch : token) {
            if (transitionFunction.find({currentState, ch}) != transitionFunction.end()) {
                currentState = transitionFunction[{currentState, ch}];
                lexeme += ch;
            } else {
                isValid = false; // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ù†ØªÙ‚Ø§Ù„ -> ØªÙˆÙƒÙ† ØºÙŠØ± ØµØ§Ù„Ø­
                break;
            }
        }

        // ğŸ”¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªÙˆÙƒÙ† ØµØ­ÙŠØ­Ù‹Ø§ Ø£Ù… Ù„Ø§
        if (isValid && finalStates.find(currentState) != finalStates.end()) {
            if (tokenTypes[currentState] == "Color" && validColors.find(lexeme) == validColors.end()) {
                cout << lexeme << " => Invalid Token" << endl;
            } else {
                cout << lexeme << " => " << tokenTypes[currentState] << endl;
            }
        } else {
            cout << lexeme << " => Invalid Token" << endl;
        }
    }

    return 0;
}

Ø§Ù†Ø§ Ø¹Ø§ÙˆØ² ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¹Ù„ÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø¯Ù‡ 
Ø§ÙˆÙ„ Ø­Ø§Ø¬Ù‡ 
tokenTypes[2] = "Open";  => Ø¹Ø§ÙˆØ² Ø±Ù‚Ù… 2 Ø¯Ù‡ ÙŠØ¨Ù‚ÙŠ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒ Ù…Ù† finalStates 
Ø¹Ø´Ø§Ù† Ø§Ù„ finalStates ÙÙŠÙ‡Ø§ ÙƒÙ„ Ø§Ù„ÙØ§ÙŠÙ†Ù„
 

___________________________________

    map<int, string> tokenTypes;
    for (int i = 0; i < finalStates.size();i++)
    {
        string tok , s;
        s = inputTokenTypes >> tok;
        tokenTypes[finalStates.at(i)] = s;
    }  
Open
Number
Color
Comma
Close => Ø¯Ù‡ Ø§Ù„ÙŠ Ù…ÙƒØªÙˆØ¨ ÙÙŠ Ø§Ù„Ù…Ù„Ù 
s = inputTokenTypes >> tok; => Ø¬Ø§ÙŠØ¨Ù„ÙŠ Ø§ÙŠØ±ÙˆØ± Ù‡Ù†Ø§

Ùˆ Ø¯Ù‡ Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ„Ù‡ 
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <sstream>
using namespace std;

int main() {
    ifstream inputAlphabet("Alphabet.txt");
    vector<char> alphabets;
    char c;
    while (inputAlphabet >> c) {
        alphabets.push_back(c);
    }

    ifstream inputAutomaton("Automaton.txt");
    int numberOfStates, startState, numberOfFinalStates;
    vector<int> finalStates;
    inputAutomaton >> numberOfStates >> startState >> numberOfFinalStates;
    for (int i = 0; i < numberOfFinalStates; i++) {
        int finalState;
        inputAutomaton >> finalState;
        finalStates.push_back(finalState);
    }

    ifstream inputTransition("Transition.txt");
    map<pair<int, char>, int> transitionFunction;
    int fromState, toState;
    while (inputTransition >> fromState >> c >> toState) {
        transitionFunction[{fromState, c}] = toState;
    }

    ifstream inputTokenTypes("TokenTypes");

    map<int, string> tokenTypes;
    for (int i = 0; i < finalStates.size();i++)
    {
        string tok , s;
        s = inputTokenTypes >> tok;
        tokenTypes[finalStates.at(i)] = s;

    }


    return 0;
}


___________________


#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <sstream>
using namespace std;

int main() {
    ifstream inputAlphabet("Alphabet.txt");
    vector<char> alphabets;
    char c;
    while (inputAlphabet >> c) {
        alphabets.push_back(c);
    }

    ifstream inputAutomaton("Automaton.txt");
    int numberOfStates, startState, numberOfFinalStates;
    vector<int> finalStates;
    inputAutomaton >> numberOfStates >> startState >> numberOfFinalStates;
    for (int i = 0; i < numberOfFinalStates; i++) {
        int finalState;
        inputAutomaton >> finalState;
        finalStates.push_back(finalState);
    }

    ifstream inputTransition("Transition.txt");
    map<pair<int, char>, int> transitionFunction;
    int fromState, toState;
    while (inputTransition >> fromState >> c >> toState) {
        transitionFunction[{fromState, c}] = toState;
    }

    ifstream inputTokenTypes("TokenTypes.txt");

    map<int, string> tokenTypes;
    int index = 0;
    string s;

    while (getline(inputTokenTypes, s) && index < finalStates.size()) {
        tokenTypes[finalStates[index]] = s;
        index++;
    }
    
    ifstream inputValidColor("ValidColors.txt");
    
    vector<string> ValidColors;
    while (getline(inputValidColor,s))
    {
        ValidColors.push_back(s);
    }
    
    ofstream outputToken("Tokens.txt");
    string line;
    cout << "Entre Input: ";

    getline(cin, line);
    vector<char> inputUser(line.begin(), line.end());
    
    for (const auto& item : inputUser)
    {
        string buffer = "";
        int curentState = startState;

        if (item == alphabets[0])
        {
            outputToken << alphabets[0] << " => " << tokenTypes[2] << endl;
        } 
        else if(item == alphabets[1])
        {
            outputToken << alphabets[1] << " => " << tokenTypes[6] << endl;
        }
        else if (item == alphabets[2])
        {
            outputToken << alphabets[2] << " => " << tokenTypes[5] << endl;
        }
        else if (isdigit(item))
        {

        }
    }

    return 0;
}

Ø§Ù†Ø§ Ø¹Ø§ÙˆØ² Ø§Ù‡Ù†Ø¯Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø¯Ù‡ Ø§Ù†Ù‡ ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ Digits 
Ùˆ ÙŠØ´ÙˆÙ Ø§Ù„Ø±Ù‚Ù… ÙƒÙ„Ù‡ ÙˆÙŠÙƒØªØ¨ ÙÙŠ 
outputToken  Number 
Ùˆ ÙŠØ¬Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„ÙØ§ÙŠÙ„ Ø¨ØªØ§Ø¹Ù‡Ø§ Ø¨Ø§Ù„ index 
Ø§Ù„Ø®Ø§Øµ Ø¨ÙŠÙ‡Ø§ 
Ùˆ ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø­Ø±ÙˆÙ 
ÙˆÙŠØªØ´ÙŠÙƒ Ø¹Ù„ÙŠ Ø§Ù„ÙƒÙ„ÙƒØ® Ø¨Ø¹Ø¯ Ù…Ø§ ØªØªØ¬Ù…Ø¹ Ø§Ù†Ù‡Ø§ Ù…Ù† ValidColor 
ÙˆÙ„Ø§ Ù„Ø§


Ø¹Ø§ÙˆØ²Ùƒ ØªØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ÙÙŠÙƒØªÙˆØ± Ø¨Ø³ 
ÙˆØ¹Ø§ÙˆØ²Ùƒ ØªØ¹Ù…Ù„ Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù† Ù‡Ùˆ Ù„Ùˆ Ø¨Ù‚ÙŠ
(red,fr,1)
( => Open
red => 
, => Comma
fr => Invalid Token
, => Comma
1 => Number 
) => Close
ÙˆÙ‡ØªÙ„Ø§Ù‚ÙŠ ÙƒÙ„ Ø§Ù„Ø¯Ø§ØªØ§ ÙÙŠ Ø§Ù„ÙØ§ÙŠÙ„Ø§Øª 


