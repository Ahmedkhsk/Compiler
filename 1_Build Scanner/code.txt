#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <unordered_map>
#include <algorithm>
using namespace std;

class DFA
{
  string input;
  vector<string> states;
  string startState;
  vector<string> finalStates;
  unordered_map<string, unordered_map<char, string>> transitionTable;
  char sparator = ',';

public:
  vector<string> tokens;
  // read input from file
  void readInput(string path)
  {
    ifstream inputFile(path);
    getline(inputFile, input);
  }

  // read states from file
  void readStates(string path)
  {
    ifstream statesFile(path);
    string str;
    getline(statesFile, str);
    states = split(str, sparator);
    // read start state
    getline(statesFile, startState);
    // read final statst
    getline(statesFile, str);
    finalStates = split(str, sparator);
  }

  // split string method
  vector<string> split(string str, char sparator)
  {
    vector<string> res;
    string text;
    stringstream ss(str);
    while (getline(ss, text, sparator))
    {
      res.push_back(text);
    }
    return res;
  }

  // read transition table
  void readTransitionTable(string path)
  {
    ifstream transitionFile(path);
    string currentState, nextState;
    char acceptedChar;
    while (transitionFile >> currentState >> acceptedChar >> nextState)
    {
      transitionTable[currentState][acceptedChar] = nextState;
    }
  }

  // check current state
  bool checkCurrentState(string state)
  {
    for (int i = 0; i < finalStates.size(); i++)
    {
      if (finalStates.at(i) == state)
      {
        return true;
      }
    }
    return false;
  }

  // to get corrosponding token from value
  // this method changed according to DFA
  string getCorrospondingToken(string value)
  {

    if (value == "(")
    {
      return "Open Parenthises";
    }
    if (value == ")")
    {
      return "Close Parenthises";
    }
    if (value == ",")
    {
      return "Comma";
    }
    bool isNumber = all_of(value.begin(), value.end(), ::isdigit);
    if (isNumber)
    {
      return "Number";
    }
    else
    {
      return "Color";
    }
  }

  // scan input string
  void check(string path)
  {
    ofstream tokensFile(path);

    string currentState = startState;
    string value = "";
    for (int i = 0; i < input.size(); i++)
    {
      char c = input[i];
      if (transitionTable[currentState].count(c))
      {
        currentState = transitionTable[currentState][c];
        value += c;
      }
      else
      {
        // check if current state is final or no
        if (checkCurrentState(currentState))
        {
          currentState = startState;
          string token = getCorrospondingToken(value);
          tokens.push_back(value + " => " + token);
          tokensFile << value + " => " + token << endl;
          value.clear();
          i--;
          continue;
        }
        else
        {
          value += c;
          tokens.push_back(value + "=> No Corrsponding Token");
          tokensFile << value + "=> No Corrsponding Token" << endl;
          currentState = startState;
          value.clear();
          continue;
        }
      }
    }

    // to check remain string when input is finshed

    if (checkCurrentState(currentState))
    {
      string token = getCorrospondingToken(value);
      tokens.push_back(value + " => " + token);
      tokensFile << value + " => " + token << endl;
      value.clear();
    }
    else
    {
      tokens.push_back(value + "=> No Corrsponding Token");
      tokensFile << value + "=> No Corrsponding Token" << endl;
    }
  }
};

int main()
{
  DFA dfa = DFA();
  dfa.readInput("Sheets/Disha/input.txt");
  dfa.readStates("Sheets/Disha/states.txt");
  dfa.readTransitionTable("Sheets/Disha/transition_fanucion.txt");
  dfa.check("Sheets/Disha/token.txt");

  for (int i = 0; i < dfa.tokens.size(); i++)
  {
    cout << dfa.tokens.at(i) << endl;
  }

  return 0;
}